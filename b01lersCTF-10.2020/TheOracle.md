![image](https://user-images.githubusercontent.com/62586375/95020369-ba644200-0638-11eb-8d61-8c88fbbc04fa.png)
В самом начале предоставляются бинарь и его исходный код на Си.
Код исходника:

![image](https://user-images.githubusercontent.com/62586375/95020380-c3551380-0638-11eb-8ec4-db93d0160d03.png)


Видно, что есть функция win(), которая открывает шелл. В функции main объявляется буфер на 16 байт, дальше
заполнение с помощью функции fgets.
Уязвимость в том, что буфер объявлен на 16 байт, но fgets может заполнить вплоть до 128, что в итоге приведет
к переполнению и вследствие чего к перетиранию данных.

Исследуем это в gdb-peda:

![image](https://user-images.githubusercontent.com/62586375/95020385-c94af480-0638-11eb-94a9-20f378ead96b.png)

После этого словили segfault:

![image](https://user-images.githubusercontent.com/62586375/95020644-53e02380-063a-11eb-85c2-2d82baeff0f4.png)

Так как архитектура программы x86-64, то в канонической форме виртуальной адресации, имеющей вид
0 x00007FFFFFFFFFFF, задействованы лишь младшие 48 бит (6 байт). В случае, если процессор видит
«неканонический» адрес (в котором первые 2 значащих байта отличны от нуля), будет вызвано исключение, и
смещение мы не посчитаем.
Поэтому нужно переполнить,посмотреть на вершину стека x/gx (g - формат целого 8-байтного
слова),взять оттуда это значение и посчитать смещение уже от него. Так мы получим его:

![image](https://user-images.githubusercontent.com/62586375/95020388-cbad4e80-0638-11eb-9d07-2921df3f0bf1.png)

Хорошо, одна задача выполнена - известно смещение. Теперь, нужно узнать адрес функции win(), чтобы,
когда мы совершим переполнение, мы перешли на адрес этой функции и получили шелл.
В gdb это можно сделать командой disas win:

![image](https://user-images.githubusercontent.com/62586375/95020391-cd771200-0638-11eb-847f-e9910668aab0.png)

Или можно сделать через objdump, кому как удобно:

![image](https://user-images.githubusercontent.com/62586375/95020394-d0720280-0638-11eb-970c-45aa4c0b3023.png)

В итоге адрес win - 0x401196.
С этими данными теперь мы можем написать маленький эксплойт с помощью библиотеки pwntools для
получения шелла на удаленной машине:

![image](https://user-images.githubusercontent.com/62586375/95020781-352e5c80-063b-11eb-9d8e-c98faac0f9b4.png)

    Указываем адрес удаленной машины.
    Инициализируем полученные нами ранее данные
    Устанавливаем соединение с помощью удобной функции из модуля pwn.
    Отсылаем полезную нагрузку на удаленный процесс и устанавливаем интерактивный режим функцией
    interactive() из модуля pwn для удобного взаимодействия с шеллом.

Запустив скрипт, получаем удаленный шелл:

![image](https://user-images.githubusercontent.com/62586375/95020395-d23bc600-0638-11eb-9201-7d98edfd20be.png)
